# Domain Driven Design (DDD)

**DDD (Domain-Driven Design)** - це методологія проектування програмних систем, яка акцентує на розумінні та втіленні бізнес-логіки у програмному коді. DDD намагається змістити фокус з технічних аспектів розробки на розуміння бізнес-процесів та доменної логіки, забезпечуючи більш ефективну співпрацю між розробниками та бізнес-аналітиками.

DDD використовується в різних видах програмного забезпечення, включаючи:
Системи управління бізнесом
Системи підтримки клієнтів
Системи штучного інтелекту
Системи віртуальної та доповненої реальності

DDD також використовується в різних галузях, включаючи:
Фінанси
Медицина
Освіта
Роздрібна торгівля
Виробництво

## Domain Model

Один із ключових понять у DDD - це "Domain Model" (доменна модель). Доменна модель - це абстрактне відображення ключових елементів бізнес-домену у вигляді об'єктів, класів та взаємозв'язків між ними у програмному коді. Вона відображає бізнес-логіку, процеси та поняття домену в програмному середовищі.

Доменна модель в DDD використовується для наступних цілей:

1. **Зрозуміння бізнес-логіки**: Вона допомагає розробникам та бізнес-аналітикам глибше зрозуміти бізнес-процеси та вимоги до системи.

2. **Вдосконалення комунікації**: Доменна модель створює спільну мову між розробниками, аналітиками та стейкхолдерами, сприяючи ефективнішій співпраці та зменшенню непорозумінь.

3. **Забезпечення єдності**: Доменна модель допомагає підтримувати єдність у розробці, уникнення розпливчатості та надмірного розділення бізнес-логіки.

4. **Орієнтованість на бізнес-потреби**: Доменна модель дозволяє розробникам створювати програмне забезпечення, яке більш точно відображає потреби та процеси бізнесу.

5. **Спрощення розробки**: Використання доменної моделі дозволяє створювати більш структурований та керований код, що полегшує розробку та підтримку програмного продукту.

Доменну модель можна використовувати на будь-якому етапі розробки програмної системи, але вона найбільш корисна на етапах аналізу вимог, проектування та реалізації. Вона може бути втілена у вигляді класів, інтерфейсів, сервісів та інших елементів програмного коду.






**Domain model** складається з наступних компонентів:
* Сутності – це основні об’єкти в предметній області. Сутності мають властивості та методи, які описують їхню поведінку.
* Відносини – це зв’язки між сутностями. Відносини можуть бути ієрархічними, асоціативними або комбінованими.
* Правила бізнесу – це правила, які регулюють поведінку сутностей та відносин. Правила бізнесу можуть бути жорсткими або м’якими.
* Відомості – це дані, які використовуються сутностіми. Дані можуть бути зберігатися в реляційній базі даних, NoSQL базі даних або в пам’яті.

Domain model створюється у співпраці з експертами предметної області та розробниками. Етапи створення domain model включають:
Вивчення предметної області
Ідентифікація сутностей, відносин, правил бізнесу та даних
Створення моделі предметної області
Впровадження моделі предметної області в програмному забезпеченні


Отже, ще раз Доменна модель є ключовим поняттям у методології Domain-Driven Design (DDD), і вона відіграє важливу роль у розробці програмних систем з фокусом на бізнес-логіці та потребах клієнта. Давайте розглянемо доменну модель більш детально:

1. **Представлення реального світу**: Доменна модель відображає ключові поняття, об'єкти, взаємозв'язки та процеси реального бізнес-домену у програмному коді. Вона намагається відобразити спосіб, яким бізнес-діяльність функціонує в реальному світі, тобто предметну область (domain), на яку спрямована програма.

2. **Концептуальна абстракція**: Доменна модель працює на рівні абстракції, що дозволяє відокремити бізнес-логіку від технічних деталей. Це дозволяє зосередитися на важливих бізнес-аспектах та зрозуміти, як різні об'єкти взаємодіють між собою.

3. **Концептуальні класи та взаємозв'язки**: Доменна модель включає в себе структури даних (класи, об'єкти) та взаємозв'язки між ними. Ці структури відображають поняття та об'єкти домену, такі як товари, замовлення, клієнти тощо.

4. **Словник домену**: У DDD створюється словник домену, який містить ключові терміни, поняття та їх визначення. Це допомагає забезпечити єдність мови між розробниками, бізнес-аналітиками та стейкхолдерами.

5. **Агрегати та сутності**: У доменній моделі використовуються поняття агрегатів та сутностей. Агрегат - це група пов'язаних об'єктів, де один з них виступає в якості кореня агрегата і відповідає за цілісність та управління іншими об'єктами. Сутність - це об'єкт, який існує сам по собі і має ідентифікатор.

6. **Загальна логіка домену**: Доменна модель включає в себе бізнес-правила, обмеження та логіку, яка визначає, як система повинна поводитися в різних ситуаціях.

7. **Підтримка еволюції системи**: Доменна модель може змінюватися разом із змінами в бізнес-процесах або вимогах клієнта. Це дозволяє системі легше адаптуватися до нових вимог і змін.

8. **Використання взаємодії зі стейкхолдерами**: Доменна модель може використовуватися як інструмент для спілкування зі стейкхолдерами та виявлення їх потреб.

Доменна модель є центральною частиною DDD і її розробка вимагає спільної роботи бізнес-аналітиків, розробників, архітекторів та інших учасників команди. Вона допомагає створити зрозумілий, структурований та ефективний код, який відображає бізнес-реалії та вимоги клієнта.


## Strategic DDD (Strategic Domain-Driven Design) та Tactical DDD (Tactical Domain-Driven Design)



Strategic DDD (Strategic Domain-Driven Design) та Tactical DDD (Tactical Domain-Driven Design) - це два різних рівні підходів в методології Domain-Driven Design (DDD), які спільно спрямовані на вдосконалення процесу проектування та розробки програмних систем з фокусом на бізнес-логіку. Давайте розглянемо їх основні пункти, використання, а також плюси та мінуси кожного рівня.

### Strategic DDD (Стратегічний рівень):

Стратегічний DDD фокусується на великій картині та організаційних аспектах розробки програмного продукту. Основні пункти:

1. **Bounded Contexts (Обмежені Контексти)**: Визначається границя, в межах якої терміни та поняття мають конкретний сенс. Це допомагає уникнути невідповідностей між різними частинами системи.

2. **Context Mapping (Картографування Контекстів)**: Визначення взаємозв'язків між обмеженими контекстами, наприклад, як вони взаємодіють між собою.

3. **Shared Kernel (Спільне Ядро)**: Визначає мінімальний набір спільних понять та логіки між різними контекстами.

### Tactical DDD (Тактичний рівень):

Тактичний DDD більше спрямований на деталі та технічні аспекти проектування. Основні пункти:

1. **Entities (Сутності)**: Об'єкти, які мають ідентифікатор і житимуть в часі, змінюючи свій стан.

2. **Value Objects (Об'єкти Значень)**: Об'єкти, які немають ідентифікатора і представляють незмінювані значення.

3. **Aggregates (Агрегати)**: Групи пов'язаних сутностей та об'єктів значень, керовані кореневими сутностями (агрегатами).

4. **Repositories (Репозиторії)**: Компоненти для зберігання та отримання сутностей.

### Використання:

- **Стратегічний DDD** використовується на початкових етапах проекту, коли потрібно визначити основні границі та взаємозв'язки між областями бізнесу.

- **Тактичний DDD** використовується при розробці конкретних функціональних модулів, коли необхідно більше уваги приділити деталям проектування та реалізації.

### Плюси та мінуси:

**Плюси Strategic DDD**:
- Забезпечує ясний взаємозв'язок між бізнес-контекстами.
- Допомагає уникнути невідповідностей між різними частинами системи.

**Мінуси Strategic DDD**:
- Може бути важко розібратися на початкових етапах розробки.
- Потребує додаткового часу та ресурсів.

**Плюси Tactical DDD**:
- Забезпечує структурованість та чіткість в програмному коді.
- Допомагає зосередитися на конкретних завданнях проектування.

**Мінуси Tactical DDD**:
- Може бути складно зберігати збалансований підхід до деталей проектування.
- Вимагає ретельного впровадження для досягнення всіх переваг.

В реальних проектах часто використовуються обидва рівні DDD, поєднуючи стратегічний підхід для загальної організації системи та тактичний підхід для розробки конкретних модулів.




##### Коли використовувати Strategic DDD:

На початкових етапах проекту: Strategic DDD використовується на ранніх етапах проекту, коли потрібно визначити головні обмежені контексти, взаємозв'язки між ними та загальну структуру системи.
При перегляді архітектури: Якщо існуюча система потребує архітектурних змін або розширень, Strategic DDD допомагає впорядкувати та уточнити зв'язки між різними частинами.

##### Приклади у світі Java Spring Boot:

У світі Java Spring Boot Strategic DDD може бути реалізований на різних рівнях, включаючи архітектуру додатків та структуру проекту. Ось декілька прикладів:
Обмежені контексти та модулі: Велика програмна система може бути розділена на обмежені контексти або модулі, кожний з яких відповідає за певну частину бізнес-домену. Наприклад, у веб-додатку можуть бути окремі модулі для управління замовленнями, продуктами, користувачами тощо.
Context Mapping: Два модулі можуть взаємодіяти за допомогою Context Mapping паттернів. Наприклад, Shared Kernel може використовуватися для спільного використання певних класів або логіки між двома контекстами.
Мікросервісна архітектура: Велику програму можна розбити на мікросервіси, кожен з яких представляє окремий бізнес-контекст. Це дозволяє забезпечити відокремленість та масштабованість різних частин системи.

Усі ці приклади вказують на те, як Strategic DDD може бути використаний у Java Spring Boot проектах для організації системи та визначення взаємодій між різними компонентами.


**Strategic DDD** – це підхід до розробки програмного забезпечення, який фокусується на розумінні предметної області та розробці архітектури програмного забезпечення, яка відповідає потребам предметної області.

##### Основні пункти Strategic DDD включають:

* Вивчення предметної області
* Ідентифікація доменних понять
* Розробка доменної моделі
* Розробка архітектури програмного забезпечення

##### Strategic DDD слід використовувати, коли:

* Вам потрібно створити програмне забезпечення, яке відповідає складним потребам предметної області.
* Вам потрібно створити програмне забезпечення, яке є стійким до змін.
* Вам потрібно створити програмне забезпечення, яке легко підтримувати.

##### Приклади використання Strategic DDD у світі Java Spring Boot включають:

Розробка веб-додатку, яке дозволяє користувачам керувати складними бізнес-процесами.
Розробка системи, яка відповідає вимогам регуляторних органів.
Розробка системи, яка інтегрується з іншими системами.
Strategic DDD є потужним інструментом, який може допомогти розробникам створити якісне програмне забезпечення, яке відповідає потребам користувачів. Однак DDD є складним підходом, і його не слід використовувати без ретельного планування.
Ось кілька додаткових прикладів того, як Strategic DDD можна використовувати у світі Java Spring Boot:
* Ви можете використовувати Strategic DDD для створення єдиної мови між розробниками та фахівцями з предметної області. Це може допомогти покращити комунікацію та розуміння, що може призвести до більш якісного програмного забезпечення.
* Ви можете використовувати Strategic DDD для створення архітектури програмного забезпечення, яка є стійкою до змін. Це може допомогти вам уникнути необхідності переписувати програмне забезпечення щоразу, коли потрібно внести зміни.
* Ви можете використовувати Strategic DDD для створення програмного забезпечення, яке легко підтримувати. Це може допомогти вам заощадити час і гроші в довгостроковій перспективі.



##### Коли використовувати Tactical DDD:

Під час проектування компонентів: Tactical DDD використовується під час проектування внутрішньої структури окремих компонентів системи. Він допомагає визначити, які об'єкти входять в домен, як вони взаємодіють та які поняття мають бути реалізовані як сутності, значення чи агрегати.
При створенні бізнес-логіки: Tactical DDD використовується для реалізації бізнес-логіки та взаємодії між об'єктами. Він допомагає вирішити, які об'єкти мають змінювати стан, які - ні, та як забезпечити цілісність даних.

##### Приклади у світі Java Spring Boot:

У світі Java Spring Boot Tactical DDD може бути реалізований за допомогою структури проекту та певних паттернів проектування. Ось декілька прикладів:
Entities (Сутності): Створення класів, які представляють сутності бізнес-домену, наприклад, User, Order, Product. Ці класи мають ідентифікатор та можуть змінювати свій стан.
Value Objects (Об'єкти Значень): Створення класів для об'єктів значень, які представляють характеристики домену, наприклад, Address, Money, Date.
Aggregates (Агрегати): Створення агрегатів, які об'єднують сутності та об'єкти значень. Наприклад, в агрегаті Order можуть бути включені сутності OrderItem та об'єкти значень ShippingAddress.
Repositories (Репозиторії): Використання Spring Data JPA для створення репозиторіїв, які забезпечують зберігання та отримання сутностей з бази даних.
Ці приклади показують, як Tactical DDD може бути реалізований у Java Spring Boot проектах для структуризації та організації бізнес-логіки.


**Tactical DDD** – це підхід до розробки програмного забезпечення, який фокусується на розробці коду, який відповідає потребам предметної області.

##### Основні пункти Tactical DDD включають:

* Розробка коду, який відповідає доменній моделі
* Розробка тестів одиниць
* Розробка тестів інтеграції
* Розробка тестів системного рівня

##### Tactical DDD слід використовувати, коли:

* Вам потрібно створити програмне забезпечення, яке відповідає простим потребам предметної області.
* Вам потрібно створити програмне забезпечення, яке потрібно швидко розробити.
* Вам потрібно створити програмне забезпечення, яке потрібно швидко впровадити.

##### Приклади використання Tactical DDD у світі Java Spring Boot включають:

* Розробка простого веб-додатку, яке дозволяє користувачам виконувати базові завдання.
* Розробка системи, яка потрібно швидко впровадити, щоб задовольнити потреби бізнесу.
* Розробка системи, яка потрібно швидко розробити, щоб відповісти на нову конкурентну загрозу.

Tactical DDD є більш простим підходом, ніж Strategic DDD, і його можна використовувати для розробки програмного забезпечення, яке відповідає простим потребам предметної області. Однак Tactical DDD не може забезпечити того ж рівня розуміння предметної області та стійкості до змін, що Strategic DDD.
Ось кілька додаткових прикладів того, як Tactical DDD можна використовувати у світі Java Spring Boot:
Ви можете використовувати Tactical DDD для створення простих класів та методів, які легко зрозуміти та підтримувати.
Ви можете використовувати Tactical DDD для створення тестів одиниць, які допомагають гарантувати, що код працює належним чином.
Ви можете використовувати Tactical DDD для створення тестів інтеграції, які допомагають гарантувати, що різні частини коду працюють разом належним чином.
Ви можете використовувати Tactical DDD для створення тестів системного рівня, які допомагають гарантувати, що вся система працює належним чином.
Якщо ви розглядаєте можливість використання Tactical DDD у своїх проектах Java Spring Boot, я заохочую вас провести додаткове дослідження та поговорити з іншими розробниками, які мають досвід роботи з цим підходом.

## Optimistic locking і pessimistic locking

Optimistic locking і pessimistic locking - це два підходи до вирішення проблеми одночасного доступу до спільних даних.

**Optimistic locking** передбачає, що дані не будуть змінені іншими користувачами, поки ви їх змінюєте. Якщо інші користувачі змінять дані, ви отримаєте помилку.

**Pessimistic locking** передбачає, що дані будуть змінені іншими користувачами, поки ви їх змінюєте. Тому він блокує дані, щоб інші користувачі не могли їх змінювати, поки ви їх змінюєте.

Optimistic locking є більш ефективним, ніж pessimistic locking, оскільки він не блокує дані, коли вони не використовуються. Однак він менш надійний, ніж pessimistic locking, оскільки існує ймовірність того, що інші користувачі змінять дані, поки ви їх змінюєте.
Pessimistic locking є більш надійним, ніж optimistic locking, оскільки він гарантує, що дані не будуть змінені іншими користувачами, поки ви їх змінюєте. Однак він менш ефективний, ніж optimistic locking, оскільки він блокує дані, коли вони не використовуються.
У Spring Boot оптимістичне блокування можна використовувати за допомогою @Version аннотації. Ця аннотація додається до поля, яке містить версію запису. Коли ви змінюєте запис, Spring Boot перевіряє значення версії запису з версією запису в базі даних. Якщо версії відрізняються, Spring Boot отримає помилку.
Пессимістичне блокування можна використовувати за допомогою @Lock аннотації. Ця аннотація додається до методу, який змінює запис. Коли ви викликаєте метод, Spring Boot блокує запис, щоб інші користувачі не могли його змінювати.
Який підхід використовувати, залежить від конкретних потреб вашої програми. Якщо вам потрібно забезпечити максимальну надійність, ви повинні використовувати pessimistic locking. Якщо вам потрібно забезпечити максимальну ефективність, ви повинні використовувати optimistic locking.
Звісно. Ось приклади коду для оптимістичного блокування:

      Java
      `@Entity
      public class Product {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private Long id;
         
         @Version
         private Long version;
         
         private String name;
         
         private Double price;
         
         public Product() {
         }
         
         public Product(String name, Double price) {
            this.name = name;
            this.price = price;
         }
         
         // getters and setters
      }
         
         @Service
         public class ProductService {
         
            @Autowired
            private ProductRepository productRepository;
            
            public Product saveProduct(Product product) {
            return productRepository.save(product);
            }
            
            public Product updateProduct(Long id, Product product) {
            Product existingProduct = productRepository.findById(id).orElseThrow(() -> new ProductNotFoundException(id));
            
                if (existingProduct.getVersion() != product.getVersion()) {
                  throw new OptimisticLockingException();
                }
            
                existingProduct.setName(product.getName());
                existingProduct.setPrice(product.getPrice());
            
                return productRepository.save(existingProduct);
            }
         }`

У цьому прикладі ми використовуємо аннотацію @Version для додавання поля версії до класу Product. Коли ми зберігаємо продукт, Spring Boot перевіряє значення версії продукту з версією продукту в базі даних. Якщо версії відрізняються, Spring Boot отримає помилку OptimisticLockingException.
Ось приклад коду для песимістичного блокування:

Java
      `@Entity
      public class Product {
      
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      private String name;
      
      private Double price;
      
      public Product() {
      }
      
      public Product(String name, Double price) {
      this.name = name;
      this.price = price;
      }
      
      // getters and setters
      }
      
      @Service
      public class ProductService {
      
      @Autowired
      private ProductRepository productRepository;
      
      public Product saveProduct(Product product) {
      return productRepository.save(product);
      }
      
      public Product updateProduct(Long id, Product product) {
      Product existingProduct = productRepository.findByIdForUpdate(id);
      
          existingProduct.setName(product.getName());
          existingProduct.setPrice(product.getPrice());
      
          return productRepository.save(existingProduct);
      }
      }`


У цьому прикладі ми використовуємо аннотацію @Lock з параметром LockModeType.PESSIMISTIC_WRITE для блокування продукту, коли ми його оновлюємо. Це гарантує, що інші користувачі не зможуть оновити продукт, поки ми його не оновили.

## Domain Events

Domain Events - це важлива концепція в методології Domain-Driven Design (DDD), яка допомагає управляти змінами стану та взаємодією об'єктів в бізнес-домені. Domain Events використовуються для передачі інформації про події, які сталися в системі, і можуть використовуватися для реалізації асинхронних процесів, збереження аудиту, спостереження за змінами тощо.

Основні концепції та використання Domain Events:

1. **Подія домену (Domain Event)**: Це об'єкт, який відображає конкретну подію або зміну стану в бізнес-домені. Він містить інформацію про те, що сталося, коли і додаткові дані, необхідні для обробки події.

2. **Важливість та сутність**: Domain Events допомагають відокремити логіку подій від об'єктів та їхнього стану. Це дозволяє підтримувати чіткі та зрозумілі моделі домену.

3. **Публікація та підписка**: Domain Events можуть бути опубліковані і підписані іншими об'єктами в системі. Це дозволяє іншим компонентам реагувати на події та виконувати додаткові дії.

4. **Асинхронні процеси**: Доменні події можуть бути використані для реалізації асинхронних процесів, коли обробка подій відбувається окремо від основного потоку виконання.

5. **Збереження аудиту**: Доменні події можуть слугувати для ведення журналу аудиту або історії змін у системі.

6. **Уникнення змін у доменних об'єктах**: Використання Domain Events дозволяє уникнути прямого змінювання стану об'єктів внаслідок певних подій. Замість цього, подія може бути опрацьована у відповідному обробнику (event handler).

Приклад використання Domain Events у світі Java Spring Boot:

Допустимо, ми розробляємо електронний магазин на Java Spring Boot. Ми маємо сутність `Order`, яка може мати статус "Замовлено", "В процесі", "Відправлено" тощо. Ми також хочемо надсилати електронні повідомлення покупцям після зміни статусу їхніх замовлень.

Один із можливих підходів може виглядати так:

1. **Створення Domain Event**: Створимо клас `OrderStatusChangedEvent`, який містить інформацію про зміну статусу замовлення, ID замовлення та новий статус.

```java
public class OrderStatusChangedEvent {
    private Long orderId;
    private OrderStatus newStatus;

    // конструктор, геттери, сеттери
}
```

2. **Опублікування Domain Event**: При зміні статусу замовлення, ми можемо опублікувати відповідний Domain Event.

```java
public class Order {
    // ...
    
    public void changeStatus(OrderStatus newStatus) {
        // Зміна статусу замовлення
        
        // Опублікування події
        OrderStatusChangedEvent event = new OrderStatusChangedEvent(this.getId(), newStatus);
        eventPublisher.publishEvent(event);
    }
}
```

3. **Підписка на Domain Event**: Ми можемо мати обробник, який підписується на ці події та відправляє електронні повідомлення.

```java
@Component
public class OrderStatusChangedHandler implements ApplicationListener<OrderStatusChangedEvent> {
    @Autowired
    private EmailService emailService;

    @Override
    public void onApplicationEvent

(OrderStatusChangedEvent event) {
        Long orderId = event.getOrderId();
        OrderStatus newStatus = event.getNewStatus();
        
        // Отримати інформацію про замовлення та покупця
        
        // Відправити електронне повідомлення
        emailService.sendOrderStatusNotification(orderId, newStatus);
    }
}
```

Цей приклад ілюструє, як Domain Events можуть бути використані для сповіщення покупців про зміни в їхніх замовленнях у Java Spring Boot додатку.


Domain events створюються, коли трапляється подія в домінантній моделі. Вони містять інформацію про подію, таку як час, коли вона відбулася, користувач, який її викликав, і дані, які були змінені.
Domain events можуть використовуватися різними способами. Наприклад, вони можуть бути використані для:
* Створення журналу подій
* Відстеження історії змін у домінантній моделі
* Сигналізація про події іншим частинам програми
* Інтеграція з іншими системами

Domain events є потужним інструментом, який може допомогти зробити програмне забезпечення більш стійким до змін і зрозумілим. Вони також можуть допомогти покращити комунікацію між різними частинами програми.
Ось кілька прикладів того, як domain events можна використовувати у світі Java Spring Boot:
Ви можете використовувати domain events для створення журналу подій. Це може допомогти вам відстежувати історію змін у домінантній моделі, що може бути корисним для діагностики проблем.
Ви можете використовувати domain events для відстеження історії змін у домінантній моделі. Це може допомогти вам гарантувати, що ваша домінантна модель завжди знаходиться в стані, який відповідає вимогам бізнесу.
Ви можете використовувати domain events для сигналізації про події іншим частинам програми. Це може допомогти вам створити більш децентралізовану програму, в якій різні частини програми можуть взаємодіяти одна з одною без прямого зв’язку.
Ви можете використовувати domain events для інтеграції з іншими системами. Це може допомогти вам обмінюватися інформацією між вашою програмою та іншими системами.


## Domain Service


Domain service – це тип сервісу, який відповідає за виконання бізнес-логіки в програмі. Domain services зазвичай створюються на основі доменної моделі програми і використовуються для надання послуг іншим компонентам програми.
Domain services мають кілька переваг перед іншими типами сервісів, зокрема:
* Вони відповідають за виконання бізнес-логіки, що може допомогти зробити програму більш стійкою до змін.
* Вони можуть бути повторно використані в різних частинах програми, що може допомогти зробити програму більш модульною і легко масштабувати.
* Вони можуть бути протестовані в ізоляції, що може допомогти зробити програму більш надійною.

Domain services є цінним інструментом, який може допомогти зробити програму більш якісною і зручною у використанні.
Ось кілька прикладів того, як domain services можна використовувати у світі Java Spring Boot:
* Ви можете використовувати domain services для надання послуг іншим компонентам програми, наприклад, UI компоненту або репозиторій.
* Ви можете використовувати domain services для виконання бізнес-логіки, яка не може бути легко реалізована в UI компоненті або репозиторії.
* Ви можете використовувати domain services для надання послуг іншим системам, наприклад, веб-сервісу або базі даних.

Ось кілька додаткових деталей про domain services:
* Domain services зазвичай створюються на основі доменної моделі програми. Це означає, що вони повинні використовувати ті ж терміни та визначення, що й домінантна модель.
* Domain services зазвичай пишуться на тому ж мовою програмування, що й решта програми. Однак вони можуть бути написані на іншій мові програмування, якщо це потрібно для певного завдання.
* Domain services зазвичай тестуються в ізоляції. Це означає, що вони повинні бути протестовані без необхідності тестувати інші компоненти програми.
* Domain services зазвичай документуються. Це означає, що їхня функціональність повинна бути описана в документації.
* Domain services є цінним інструментом, який може допомогти зробити програму більш якісною і зручною у використанні. Однак важливо використовувати їх у правильних ситуаціях.
* Domain Service - це ключовий елемент методології Domain-Driven Design (DDD), який використовується для вирішення конкретних бізнес-задач або обробки доменної логіки, яка не пов'язана з конкретними об'єктами сутностей чи агрегатів. Domain Service допомагає уникнути прямого зв'язку між сутностями та зберігає бізнес-логіку у певних контекстах.


##### Основні аспекти та використання Domain Service:

1. **Бізнес-логіка, що не належить сутностям**: Domain Service використовується для реалізації бізнес-логіки, яка не пов'язана напряму з однією конкретною сутністю чи агрегатом. Це можуть бути завдання, які вимагають обчислень, валідації, обробки зовнішніх систем тощо.

2. **Використання з певним контекстом**: Domain Service визначається для конкретного контексту домену. Він обробляє лише ті завдання, які відносяться до цього контексту, та вирішують специфічні проблеми.

3. **Уникнення повторення коду**: Domain Service допомагає уникнути дублювання бізнес-логіки у різних місцях системи, оскільки може бути використаний багаторазово.

4. **Доповнює об'єкти сутностей**: Domain Service може виконувати операції над сутностями або агрегатами, доповнюючи їх функціональність або взаємодіючи з ними.

5. **Публікація Domain Events**: В деяких випадках Domain Service може публікувати Domain Events для інших компонентів системи.

##### Приклад використання Domain Service у світі Java Spring Boot:

Давайте розглянемо приклад з електронним магазином, де нам потрібно вираховувати загальну вартість замовлення на основі цін товарів та кількості.

1. **Створення Domain Service**: Створимо Domain Service з ім'ям `OrderCalculationService`, який буде відповідати за вираховування загальної вартості замовлення.

```java
public interface OrderCalculationService {
    Money calculateTotalOrderCost(List<OrderItem> orderItems);
}
```

2. **Реалізація Domain Service**: Реалізуємо цей сервіс, використовуючи бізнес-логіку для вираховування загальної вартості замовлення.

```java
@Service
public class DefaultOrderCalculationService implements OrderCalculationService {

    @Override
    public Money calculateTotalOrderCost(List<OrderItem> orderItems) {
        Money totalCost = Money.ZERO;
        
        for (OrderItem item : orderItems) {
            Money itemTotal = item.getProduct().getPrice().multiply(item.getQuantity());
            totalCost = totalCost.add(itemTotal);
        }
        
        return totalCost;
    }
}
```

3. **Використання Domain Service**: В іншому класі, де потрібно вираховувати загальну вартість замовлення, можна використовувати цей Domain Service.

```java
public class Order {
    // ...
    
    public void recalculateTotalCost(OrderCalculationService calculationService) {
        this.totalCost = calculationService.calculateTotalOrderCost(orderItems);
    }
}
```

4. **Спрощення коду та уникнення повторення**: Використання Domain Service допомагає спростити код та уникнути дублювання бізнес-логіки, пов'язаної з вираховуванням вартості замовлення.

Цей приклад показує, як Domain Service може бути використаний для реалізації бізнес-логіки, яка не пов'язана з конкретними сутностями, у Java Spring Boot додатку.




## Application Services

Application Service - це концепція, яка також виникає з методології Domain-Driven Design (DDD). Application Services використовуються для координації роботи доменних об'єктів, виконання бізнес-операцій та обробки запитів користувача на вищому рівні абстракції. Вони виступають як фасад між інтерфейсом користувача та доменною логікою.

##### Основні аспекти та використання Application Services:

1. **Координація доменної логіки**: Application Services відповідають за координацію дій доменних об'єктів для виконання конкретних бізнес-операцій. Вони дозволяють згруповувати кілька доменних операцій у зручний для використання спосіб.

2. **Транзакційна безпека**: Application Services можуть управляти транзакціями та забезпечити консистентність даних під час виконання бізнес-операцій.

3. **Обробка запитів користувача**: Application Services надають інтерфейс для взаємодії з зовнішніми системами, такими як веб-інтерфейс, API або інші додатки. Вони обробляють запити користувача та виконують відповідні дії в доменній логіці.

4. **Події та логування**: Application Services можуть бути відповідальні за публікацію доменних подій, а також збереження аудиту чи журналу дій користувачів.

5. **Валідація даних**: Application Services можуть проводити перевірку та валідацію даних перед їхнім переданням до доменної логіки.

6. **Взаємодія з Domain Services**: Application Services можуть використовувати Domain Services для виконання певних завдань, які не належать до доменних об'єктів, але пов'язані з доменом.

##### Приклад використання Application Services у світі Java Spring Boot:

Розглянемо приклад додатку для управління замовленнями в електронному магазині з використанням Java Spring Boot.

1. **Створення Application Service**: Створимо Application Service з ім'ям `OrderService`, який буде відповідати за обробку замовлень.

```java
@Service
@Transactional
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    
    public Order createOrder(User user, List<OrderItem> items) {
        // Валідація даних, створення замовлення, виконання логіки
        // ...
        Order newOrder = new Order(user, items);
        return orderRepository.save(newOrder);
    }
    
    public void cancelOrder(Long orderId) {
        Order order = orderRepository.findById(orderId).orElseThrow(() -> new OrderNotFoundException(orderId));
        // Логіка скасування замовлення
        // ...
        orderRepository.save(order);
    }
    
    // Інші методи та операції
}
```

2. **Взаємодія з доменною логікою**: `OrderService` взаємодіє з доменними об'єктами (наприклад, `Order`), виконуючи бізнес-операції та обробляючи запити користувача.

3. **Використання в контролері**: `OrderService` може бути використаний у веб-контролерах для обробки запитів від клієнта.

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    @Autowired
    private OrderService orderService;
    
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody CreateOrderRequest request) {
        // Валідація даних та виклик OrderService
        // ...
        Order newOrder = orderService.createOrder(request.getUser(), request.getItems());
        return ResponseEntity.ok(newOrder);
    }
    
    @PostMapping("/{orderId}/cancel")
    public ResponseEntity<Void> cancelOrder(@PathVariable Long orderId) {
        // Виклик OrderService для скасування замовлення
        orderService.cancelOrder(orderId);
        return ResponseEntity.noContent().build();
    }
    
    // Інші ендпойнти та дії
}
```

Цей приклад показує, як Application Services можуть використовуватися для координації бізнес-операцій та взаємодії з доменною логікою у Java Spring Boot додатку.

## Domain Service та Application Service

Domain Service та Application Service - це дві різні концепції в методології Domain-Driven Design (DDD), які мають різні функції та використання у проекті.

1. **Domain Service**:
    - **Функція**: Domain Service використовується для реалізації конкретної бізнес-логіки, яка пов'язана з певним аспектом домену, але не належить безпосередньо до конкретних сутностей або агрегатів.
    - **Сфера застосування**: Використовується для обчислень, валідації, обробки зовнішніх систем, обробки подій та інших завдань, які вимагають обробки даних безпосередньо на рівні домену.
    - **Публікація подій**: Не обов'язково публікує доменні події, але може бути відповідальним за певні дії після виконання бізнес-операцій.
    - **Приклад**: Сервіс вираховування вартості замовлення, який використовує ціни товарів та кількість для розрахунку загальної вартості.

2. **Application Service**:
    - **Функція**: Application Service використовується для координації дій між доменними об'єктами, обробки запитів користувача та виконання бізнес-операцій на вищому рівні абстракції.
    - **Сфера застосування**: Використовується для взаємодії з зовнішніми системами (наприклад, веб-інтерфейсом чи API), обробки запитів користувача, валідації даних, обробки транзакцій тощо.
    - **Публікація подій**: Може бути відповідальним за публікацію доменних подій та збереження аудиту.
    - **Приклад**: Сервіс управління замовленнями, який взаємодіє з доменними об'єктами, виконує бізнес-операції замовлення та обробляє запити від клієнта.

Отже, різниця між Domain Service та Application Service полягає у їхніх функціях, сфері застосування та ролі у взаємодії з доменною логікою та зовнішніми системами. Обидва концепти важливі для структурування та організації бізнес-логіки у великих програмних проектах, і вони можуть використовуватися разом для досягнення кращої архітектурної якості та зрозумілості коду.


**Domain services і application services** – це два типи сервісів, які використовуються в розробці програмного забезпечення. Domain services відповідають за виконання бізнес-логіки в програмі, тоді як application services надають корисність користувачам програми.
Domain services зазвичай створюються на основі доменної моделі програми і використовуються для надання послуг іншим компонентам програми. Вони відповідають за виконання бізнес-логіки, яка не може бути легко реалізована в UI компоненті або репозиторії. Domain services можуть бути повторно використані в різних частинах програми, що може допомогти зробити програму більш модульною і легко масштабувати.
Application services надають корисність користувачам програми. Вони зазвичай створюються на основі доменної моделі програми і використовуються для надання послуг користувачам програми. Application services можуть бути повторно використані в різних частинах програми, що може допомогти зробити програму більш модульною і легко масштабувати.
У Spring Boot domain services і application services можуть бути розділені за допомогою різних пакетів. Domain services зазвичай поміщаються в пакет com.example.domain, тоді як application services зазвичай поміщаються в пакет com.example.app.
Ось приклад коду domain service:
```
package com.example.domain;

public class OrderService {

    private OrderRepository orderRepository;

    public OrderService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    public Order createOrder(Order order) {
        return orderRepository.save(order);
    }

    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId).orElse(null);
    }

    public void updateOrder(Order order) {
        orderRepository.save(order);
    }

    public void deleteOrder(Long orderId) {
        orderRepository.deleteById(orderId);
    }

}
```


Ось приклад коду application service:
```
package com.example.app;

import com.example.domain.OrderService;

public class OrderController {

    private OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @GetMapping("/orders")
    public List<Order> getOrders() {
        return orderService.getOrders();
    }

    @PostMapping("/orders")
    public Order createOrder(@RequestBody Order order) {
        return orderService.createOrder(order);
    }

    @GetMapping("/orders/{orderId}")
    public Order getOrder(@PathVariable Long orderId) {
        return orderService.getOrder(orderId);
    }

    @PutMapping("/orders/{orderId}")
    public void updateOrder(@PathVariable Long orderId, @RequestBody Order order) {
        orderService.updateOrder(order);
    }

    @DeleteMapping("/orders/{orderId}")
    public void deleteOrder(@PathVariable Long orderId) {
        orderService.deleteOrder(orderId);
    }

}
```
Як бачите, domain service і application service мають різні відповідальності. Domain service відповідає за виконання бізнес-логіки, тоді як application service надає корисність користувачам програми.
